import logging
import socket
import json

from datetime import datetime, timedelta
from select import select
from random import randrange
from zlib import crc32
from Crypto.PublicKey import RSA


_cached_infos_time = datetime.min
_cached_infos = []


def get_device_infos(*, cache_time=5, timeout=0.2, port=20002):
    global _cached_infos_time
    global _cached_infos

    if cache_time and _cached_infos:
        if not isinstance(cache_time, timedelta):
            cache_time = timedelta(seconds=cache_time)

        if datetime.now() - cache_time <= _cached_infos_time:
            logging.debug('Hit broadcast cache')
            yield from _cached_infos
            return

    _cached_infos = []
    for result in _get_device_infos(timeout=timeout, port=port):
        _cached_infos.append(result)
        yield result

    _cached_infos_time = datetime.now()


def _get_device_infos(*, timeout=0.2, port=20002):
    payload = get_payload()

    for response in get_device_responses(payload, timeout=timeout, port=port):
        try:
            # The first 16 bytes are like those built by build_packet()
            yield json.loads(response[16:])

        except (IndexError, json.JSONDecodeError):
            # It's possible for something else on the network to respond in an
            #  unexpected way, so we can just drop weird responses
            pass


def get_payload():
    key = RSA.generate(2048).publickey().exportKey("PEM")

    # newline on the end and no spaces in separators to perfectly match
    #  the packets sent by vendor apps
    payload = json.dumps(
        {'params': {'rsa_key': key.decode("utf-8") + '\n'}},
        separators=(',', ':')
    )

    # Fun fact: the P100 plugs will respond just the same if you send
    #  b'\x02\x00\x00\x01\x00\x00\x11\x00\x0e\xd7\xd6\xac\x84\x0e\xfdY'
    #  which is the result of passing an empty string to build_packet()
    #
    # We send a full packet anyway, however, in case future firmware
    #  updates fix that
    return build_packet(payload)


def build_packet(string):
    # Magic prefix bytes generated by reverse-engineering the Tapo android app
    #  algorithm found in com\tplink\tdp\common\b.java
    prefix = b'\x02\x00\x00\x01\x00\x00\x11\x00\x00\x00\x00\x00Zk|\x8d'

    output_array = bytearray(prefix + string.encode('utf-8'))

    # Insert dynamic bytes that change based on the string / randomness
    output_array[4:6] = len(string).to_bytes(2, 'big')
    output_array[8:12] = randrange(268435456).to_bytes(4, 'big')

    # Insert checksum based on current array
    output_array[12:16] = crc32(output_array).to_bytes(4, 'big')

    return bytes(output_array)


def get_device_responses(payload, *, timeout=0.2, port=20002):
    sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.setblocking(0)

    sock.sendto(payload, ("255.255.255.255", port))

    while True:
        data_waiting = select((sock,), (), (), timeout)[0]
        if not data_waiting:
            break

        yield sock.recv(4096)


if __name__ == '__main__':
    import time

    logging.basicConfig(format='%(levelname)s:%(message)s',
                        level=logging.DEBUG)

    print('Uncached:')
    for device in get_device_infos():
        print(device['result']['ip'])

    print('Cached:')
    for device in get_device_infos():
        print(device['result']['ip'])

    print('Sleeping for 5.1 seconds...')
    time.sleep(5.1)
    print('Uncached:')
    for device in get_device_infos():
        print(device['result']['ip'])

    print('Uncached:')
    for device in get_device_infos(cache_time=0):
        print(device['result']['ip'])
